package main

import "fmt"

func main() {
	fullFor()
	println("==================")
	notInitFor()
	println("==================")
	notPostFor()
	println("==================")
	array()
	println("==================")
	testMap()
	println("==================")
}

// Полная запись [инициализация счетчика]; [условие]; [изменение счетчика] {}
func fullFor() {
	sum := 0
	for i := 0; i < 100; i++ {
		sum += i
	}
	fmt.Println(sum)
}

// Без инициализации = ; [условие]; [изменение счетчика] {}
func notInitFor() {
	sum := 0
	i := 0
	for ; i < 100; i++ {
		sum += i
	}
	fmt.Println(sum)
}

// Без инициализации  и счетчика = ; [условие]; {}
func notPostFor() {
	sum := 0
	k := 0
	for k < 5 {
		sum += k
		k++
	}
	fmt.Println(sum)

	//Краткая запись
	i := 1
	for i < 10 {
		fmt.Println(i * i)
		i++
	}
}

/*
Массивы (конкретное количество): - область памяти с множеством однотипных значений
var arr[5] int - объявление массива (по умолчанию ставиться 0 - значит их будет 5)
индексы с 0
animals:= make([]string, 5, 10) - еще один способ создания массива


Слайс/срез - гарантирует порядок элементов (динамический массив) смотрит на исходный массив: - длин (len) и вместимость (cap) - в него можно добавлять и удалять элементы
для создания слайса достаточно не указывать размер массива: animal := []string{}
week := [...] int{0,1,2,3,4,5,6,7}
weekend := week[6:8] (в указанную выборку попадает 6 и 7 индекс 8 - не включается) или week[6:] (до конца)
animals:= make([]string, 5, 10) - еще один способ создания
animals:= append(animals, "lion") - добавление в слайс, при добавлении - будет скопирован предыдущий массив, увеличится его капасити и будет добавлен новый элемент


MAP(хеш-таблица/ассоциативный массив) - не гарантирует порядок элементов
var m = map[int](- это ключ)string(- это значение){
        1: "A",
        2: "B", - запятая в конце обязательна!!!
}
m[2] - получение значения из мапы
m[2] = "С" - добавление или перезапись значения
m[3] - даст пустую строку (так как ключа нет)

map:= make(map[int]string) - еще один способ создания мапы

test, isExist := m[3] - присвоит значение из мапы в test, isExist = будет true/false  в зависимости если такой ключ в мапе или нет
delete(m, 1) - удаление пары ключ+значение
*/

/*
Перебор массива - при этом можно за место индекса или значения использовать знак "_" - что бы исключить из обработки
arr := []string{"A","B","C"}
for index, letter:= range array arr{
...////
}
range - значит перебираем
*/
func array() {
	var users = [3]string{"Tom", "Alice", "Kate"}
	for index, value := range users {
		fmt.Println(index, value)
	}
	//Стандавртнвый варинт перебора, лен возращает длину массива
	for i := 0; i < len(users); i++ {
		fmt.Println(users[i])
	}
}

/*
for condition {
///
}
condition -  условие для выхода из цикла
break, return -  для выхода из цикла
*/

func testMap() {
	var m = map[string]int{
		"a": 1,
		"b": 2,
		"c": 3,
		"d": 4,
	}
	for k, v := range m {
		fmt.Println(k, v)
	}
}

/*
Указатели (на адрес ячейки памяти):
& - оператор
* - оператор
new(T) - универсальная функция

Получение указателя на тип данных string:

phrase := "test"
phrasePtr := &phrase - получает адрес в памяти (использовать нужно когда точно везде надо изменить объект)
fmt.Println(phrasePtr)
fmt.Println(*phrasePtr) - выводит значение из указанного адреса
*/

/*
Struct (структуры) - объекты - характеристики:
Наименование функции конструктор начинается со слова New (так принято делать)
Встраивание структур:

type Vehicle struct {
Brand string
Model string
Goe Geo - встраивание с отдельным полем
или
Geo - встраивание без отдельного поля (как будто поля из Geo struct находятся в Vehicle struct) аналогично с интерфейсами
}

type Geo struct {
Latitude string
Longitude string
}

*/

/*
Интерфейсы - способ описания действий объекта (структура - реализует интерфейс тогда и только тогдаБ когда реализует все методы из интерфейса)
type Test interface { (способ задания)
.....
}
*/

/*
defer:
выполнение перед выходом из функции (до return)
всегда выполниться
несколько вызовов
освобождение ресурсов (закрыть файл как пример)

Пример:
func main() {
     defer func() {
           fmt.Println("1")
     }() - вызов анонимной функции
     fmt.Println("2")
}
Или же так:

func test() {
 fmt.Println("1")
}

func main() {
     defer test()
     fmt.Println("2")
}
*/

/*
Паника:
никто не ожидал (ссылка никуда не указывает) - тогда паника
panic("Ручной вызов")

Обычная ошибка:
*/

/*
Горутины (паралелность) функция которая работает параллельно с другими
Создает и управляет само приложение (встроенный инcтрумент внутри GO)

go - перед вызовом функции (нужно )

Каналы (ссылочный тип данных) - возомжность общения горутин между собой (для синхранизации)
Пример:
var testChanel chan int (типизированный канал для учебных целей) - только одно значение для небуферизованного канал
testChanel <- 1 (запись в канал)
val := <- testChanel (для чтения) (блокирует выполнение горутины пока не появится сообщение в канале)

chanal := make(chan int, 3) - создание буферизированного канала (когда накопится 3 сообщения все встанет если из него не читаются данные)
в него можно писать и из него можно читать (единожды - кто прочел тот и отработал если несколько горутин на одном канале)

Задание направлений канала:
var testChanel chan<- int только для отправки
var testChanel <-chan int только для получения

SELECT
*/
